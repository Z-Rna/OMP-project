\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{scrextend}
\usepackage{glossaries}
\usepackage{minted}

\makenoidxglossaries

\newglossaryentry{WLP}{name={WLP},description={Wektor Liczb Przeszukiwanych}}

\newglossaryentry{SE}{name={SE},description={Sito Erastotenesa}}

\newglossaryentry{PPLL}{name={PPLL},description={Pełny Przegląd Listy Liczb}}

\newglossaryentry{WLU}{name={WLU},description={Wektor Liczb Uporządkowanych}}

\newglossaryentry{TLP}{name={TLP},description={Tablica Liczb Pierwszch}}

\begin{document}
    \title{
        Sprawozdanie z Projektu Pierwszego \\
        \small{Laboratorium Przetwarzania Równoległego}
    }
    \author{
        \textbf{Piotr Tylczyński}\\
        \texttt{L7 / 141331} \\
        \texttt{Środa, 11:45} \\
        \texttt{piotr.tylczynski@student.put.poznan.pl}
        \and
        \textbf{Zuzanna Rękawek}\\
        \texttt{L7 / 141304} \\
        \texttt{Środa, 11:45} \\
        \texttt{zuzanna.rekawek@student.put.poznan.pl}
        \date{}
        }
    \begin{titlepage}
        \maketitle
        \centering{
            Oddane: 29.04.2021 \\
            Deadline: 29.04.2021 \\
        }
        \hfill \break
        \centering{Wersja 1}
            
            
    \end{titlepage}
    
    \tableofcontents
    \pagebreak
    
    \section{Motywacja}
        Celem niniejszego projketu jest stworzenie efektywnego programu wyszukującego liczby pierwsze w zadanym przedziale. W tym celu wykorzystamy porogramowanie równoległe. Pozwoli to na efektywniejsze wykorzystanie zasobów komputerowych jakimi dysponujemy. W wyniku otrzymamy program mogący wykorzystywać do 100\% mocy obliczeniowej procesora komputera, na którym zostanie uruchomiony. Pozwoli to nam na znaczącą redukcję czasu wykonania programu względem standardowej wersji sekwencyjnej programu.
        
        W rozwiązaniu wykorzystamy algorytm Sita Erastotenesa (\gls{SE}). Jest to algorytm pozwalający na osiągnięcie znaczącego przyspieszenia, po jego zrównolegleniu. Dodatkowo rozważymy wykorzystanie i zrównoleglanie algorytmu Pełnego Przeglądu List Liczb (\gls{PPLL}).
                 
    \section{Specyfikacja platformy uruchomieniowej}
        \begin{addmargin}{3em}
            \begin{description}
                \item[Procesor] Intel Core i5-9300H
                    \begin{description}
                        \item[Procesorów Fizycznych] 4
                        \item[Procesorów Logicznych]  8
                        \item[Pamięć Cache]  8 MB Intel® Smart Cache 
                    \end{description} 
                \item[System Operacyjny] Windows 10 Pro 20H2
                \item[IDE] Visual Studio 2019
                % TODO: check vtune version
                \item[Oprogramowanie Testujące] Intel®VTune\texttrademark Profiler
            \end{description}
        \end{addmargin}
        
    \section{Problemy i zjawiska występujące w programach równoległych}
        \subsection{Problemy Poprawnościowe}
            \subsubsection{Zjawisko wyścigu}
                Jest to zjawisko polegające na ubieganiu się o dostęp do pojedynczego zasobu przez wiele wątków. Jest to warunek konieczny wystąpienia w.w. zjawiska. Jeżeli nie zastosujemy, żadnego systemu zarządzania dostępem okaże się, że wynik wykonania programu nie będzie deterministyczny. Będzie to spowodowane przez używanie jednego zasobu przez wiele wątków. Będą one potencjalnie zapisywały do zasobu równocześnie. Spowoduje to, że wartość zapisana będzie w najlepszym przypadku wartością zapisaną przez ostatni wątek. W gorszym przypadku powstanie losowa kombinacja wartości zapisywanych przez poszczególne wątki. Kolejość informacji zapisanych w zasobie będzie zależała od czasu dostępu, stąd nazwa wyścig.
                
                Oczywiście występowanie zjawiska wyścigu nie jest porządana. Może ona doprowadzić do powstania złych wyników. W najgorszym przypadu będą one wypadkową, lub permutacją poprawnych wyników. 
                
                Rozwiązaniem problemu wyścigu jest wprowadzenie ograniczeń w dostępie do współdzielonego zasobu. W najprostszy sposób można to osiągnąć blokując zasób w czasie jego wykorzystywania przez wątek. Wtedy pozbędziemy się problemu wielodostępu i nigdy nie dopuścimy do spełnienia warunku koniecznego. Narzędziem, które może okazać się przydatne mogą być monitory, lub semafory. W naszym projekcie zastosujemy odpowiednie klauzule, które zapobiegną opisywanemu zjawisku. Będą to klauzule synchronizujące i dzielącę prace między wątkami, które zostały szczegółowo opisane poniżej, jaki i w opisach samych algorytmów.
        
        \subsection{Problemy Efektywnościowe}
            \subsubsection{Problem False Sharing}
                Polega na unieważnieniu potencjalnie nie współdzielonych danych w pmięci podręcznej procesora. Dzieje się tak, ponieważ leżą one na tej samej lini adresowej procesora. Z tego powodu jeżeli procesor wykonuje zapis do jednej z komórek pamięci to może się okazać, że narusza inną zmienną leżącą na tej samej lini pamięci. W takim wypadku, zmienna ta zostanie uznana za \emph{"brudną"} i będzie wymagała ponownego pobrania z pamięci.
                
                Zjawisko False Sharingu prowadzi do znaczengo spadku efektywności programu. W skrajnych przypadkach może okazać się, że program jest znacząco wolniejszy od swojej wersji sekwencyjnej. Jest to bezpośrednie następstwo wielokrotnego i niepotrzebnego unieważniania liń pamięci. Co sprawia, że wymagany jest dodatkowy narzut czasowy związnay z transferem danych pomiędzy poszczególnymi poziomami pamięci komputera.
                
                Rozwiązaniem problemu False Sharingu jest odpowiednia separacja przestrzenna danych. W przypadku tabel można to zapewnić przez umieszczenie wolnych miejsc pomiędzy danymi do zapisu. W ten sposób dane nie będą leżały na tej samej lini pamięci.
                
                W wyniku eksperymentu przeprowadzonego w ramach zadania pierwszego wyznaczyliśmy wielkość pojedyńczej lini pamięci na 64B
        
    \section{Zastosowane Algorytmy}
        \subsection{Opis teoretyczny}
            \subsubsection{Sito Erastotenesa}
                W swojej najprostszej formie \gls{SE} jest alogrytmem, który przyjmuje na swoje wejście wektor liczb naturalnych, uporządkowanych rosnąco z krokiem jeden - w dalszych częściach teog dokumentu nazywanych Wektorem Liczb Uporządkowanych - ()\gls{WLU}). Zastosowanie \gls{WLU} pozwala na dokonanie pewnej optymalizacji. Polega ona na sprawdzaniu tylko liczb znajdujących się przed połową takiego wektora. Optymalizacja taka jest możliwa, ponieważ \gls{WLU} jest rosnąco uporządkowany, więc wiemy, że wszystkie liczby złozone w drugiej połowie są, wielokrotnością, liczb znajdujących się w pierwszej połowie. Biorąc pod uwagę sposób działania algorytmu, który wykreśla z \gls{WLU} wszystkie wielokrotności liczb, mamy pewność, że po przejrzeniu wszystkich liczb z pierwszej połowy, wyeliminowaliśmy wszystkie pozostałe z drugiej połowy.
                
                Sam sposób działania \gls{SE} jest prosty. Dla każdej znalezionej liczby w \gls{WLU} wykreśl z \gls{WLU} wszystkie jej wielokrotności - w ten sposób pozbywamy się liczb złożonych. Następnie przejdź do kolejnej liczby w \gls{WLU} i powtórz poprzedni krok. Algorytm ten działa o ile przeglądamy liczby z zakresu 1 do N (N dowolna liczba całkowita). Jeżeli pierwszą liczbą w \gls{WLU} nie jest 1 to należy stworzyć sztuczny iterator, który będzie przechodził przez dodatkową tablicę zawierającą wszystkie liczby pierwsze (\gls{TLP}). Kolejną optymalizację jaką można dokonać jest ograniczenie wielkości tablicy liczb peirwszych. Maksymalna wymagana liczba pierwsza to pierwiastek kwadratowy z ostatniej liczby wchodzącej w skład \gls{WLU}. Tą własność można łatwo udowodnić, ponieważ największy dzielnik dowolnej liczby naturalnej nie może być większy niż pierwiastek kwadratowy z niej samej.
            
            \subsubsection{Przegląd Listy Liczb}
                Jest to jden z najprostszych algorytmów wyszukiwania liczb pierwszych. W swojej sekwencyjnej wersji polega na pełnym przejrzeniu \gls{WLU} i znalezieniu w nim liczb pierwszych. Jest to algorytm mniej skuteczny niż \gls{SE}, jednak szybszy w implementacji.
                
            \subsubsection{Określanie pierwszości liczyb}
                Działa na zasadzie iterowania się po wszystkich liczbach z zakresu 2 do wartości liczby. Jednocześnie sprawdzamy, czy któraś z liczb nie jest dzielnikiem sprawdzanej liczby. Jeżeli tak to wiemy, że dana liczba jesst liczbą złożoną. Po zakończeniu iterowania i nie znalezieniu dzielnika, możemy stwierdzić, że sprawdzana liczba jest pierwsza. Optymalizacja algorytmu polega na sprawdzaniu liczby tylko i wyłącznie nie większych niż pierwiastek kwadratowy z testowanej liczby. Uzasadnienie tego faktu można znaleźć w algorytmie \gls{SE}.
        \subsection{Realizacja praktyczna}
            \subsubsection{Wykorzystane klauzule OMP}
                \begin{description}
                    \item[\texttt{omp\_get\_max\_threads()}] podaje maksymalną dostępną w systemie liczbę procesorów logicznych
                    \item[\texttt{omp\_get\_wtime()}] zwraca czas pracy wszystkich wątków
                    \item[\texttt{\#pragma\ omp\ parallel}] rozpoczyna obszar wykonania Równoległego
                    \item[\texttt{\#pragma\ omp\ for}] pozwala na zrównoleglanie pętli dzieląc wykonywaną przez nią pracę pomiędzy dostępne wątli 
                    \item[\texttt{omp\_get\_thread\_num()}] zwraca numer aktualnie wykonywanego wątku
                    \item[\texttt{omp\_set\_num\_threads()}] ustawia maksymalną ilość wątków jakiej może używać program
                    \item[]   
                \end{description}
            \subsubsection{Sekwencyjne Określanie Pierwszości Liczb}
                \begin{figure}[H]
                    \begin{minted}[linenos]{cpp}
bool isPrime(int p)
{
	int div = 2;
	double sqrtP = (int)sqrt(p) + 1;

	for (; div < sqrtP; ++div){ 
		if(p % div == 0) 
			return false;
	}

	return true;
}
                    \end{minted}
                    \caption{Sekwencyjne Określanie Pierwszości Liczb}
                \end{figure}
                Dokładne działanie algorytmu zostało zaprezentowane w części teoretycznej. Jedyną różnicą jest zastosowanie reszty z dzielenia jako metody określania dzielnika. Jeżeli wynikiem reszty z dzielenia jest zero to wiadomo, że $div$ jest jednym z dzielników liczby $p$, co oznacza, że liczba $p$ nie jest pierwsza.
                
            \subsubsection{Sekwencyjny Przegląd Listy Liczb}
                \begin{figure}[H]
                    \begin{minted}[linenos]{cpp}
std::vector<int> sequential::withoutSieve(int start, int end, bool printOutput){
    int size = end - start + 1;
    std::vector<int> result;
    double timeStart, timeStop;
                
    result.reserve(size);
    timeStart = omp_get_wtime();
    for (size_t i = start; i <= end; ++i){
        if (isPrime(i)) {
            result.push_back(i);
        }
    }
    timeStop = omp_get_wtime();
    if(printOutput) period(timeStart, timeStop, "sequential::withoutSieve");
                
    return result;
}
                    \end{minted}
                    \caption{Sekwecyjny Przegląd Listy Liczb}
                \end{figure}
                Tak jak opisano w części teoretycznej polega na pełnym przeglądzie wszystkich liczb z podanego zakresu. Aby zpoptymalizować wykonanie programu ustalamy wielkość wynikowego wektora na samym początku. Następnie w pętli sprawdzamy wszystkie liczby w zakresie od \emph{start} do \emph{end}. Samo sprawdzanie odbywa się w funkcji \emph{isPrime}, która została szczególowo opisana wcześniej.
            \subsubsection{Sekwencyjne Sitoerastotenesa}
            \subsubsection{Równoległe Określanie Pierwszości Liczb}
                \paragraph{Podejście Naiwne}
                \paragraph{Podejście Optymalne}
            \subsection{Równoległy Przegląd Listy Liczb}
                \paragraph{Podejście Naiwne}
                \paragraph{Podejście Optymalne}
            \subsubsection{Równoległe Sito Erastotenesa - wersja domenowa}
                \paragraph{Podejście Naiwne}
                \paragraph{Podejście Optymalne}
                \subsubsection{Równoległe Sito Erastotenesa - wersja funkcyjna}
                \paragraph{Podejście Naiwne}
                \paragraph{Podejście Optymalne}
    
    \section{Prezentacja i Omówienie eksperymentu obliczeniowo-pomiarowego}
        \subsection{Metodyka wykonania eksperymetów}
                Wszystkie prezentowane eksperymenty zostały uruchomione na maszynie opisanej na początku tego sprawozdania. Do testów zostały użyte wszystkie algorytmy opisane w powyższej części sprawozdania.
                
                \noindent
                Rozmiary instanji testowych to: $(MAX = 7 * 10^7)$
                \begin{itemize}
                    \item $2 .. MAX$
                    \item $MAX / 2 .. MAX$
                    \item $2 .. MAX / 2$
                \end{itemize}
                
                \noindent
                Ilości używanych wątków to:
                \begin{description}
                    \item[jeden wątek] podejście sekwencyjne
                    \item[połowa dostępnych procesorów logicznych] każdy z rdzeni procesora powinien dostać swój wątek, w tym wypadku ilość wątków będzie równała się ilości procesorów fizycznych
                    \item[dostępne rdzenie logiczne] każdy z procesorów logicznych powinien dostać dokładnie po 2 wątki, jest to możliwe dzięki wykorzystaniu technologii HyperThreading implementowanej dla porcesorów Intel
                \end{description}
        
        \subsection{Charakterystyka Programu Testującego}
            Intel®VTune jest oprogramowaniem służącym do analizy programów sekwencyjnych oraz równoległych. Pozwala on na określenie:
            \begin{itemize}
                \item miejsc oraz funkcji, w których program spędził najwięcej czasu
                \item secji kodu, które nieefektywnie wykorzystują zasoby procesora
                \item miejsc w kodzie, które należy zoptymalizować dla lepszego działania sekwencyjnego oraz wielowątkowego
                \item punktów synchronizacji, które wprowadzają największe opóźnienia
                \item gdzie, kiedy i dlaczego program spędza duże ilości czasu na operacjach I/O
                \item czy program jest ograniczany przez CPU czy GPU
                \item wpływ różnych metod synchronizacji na efektywność programu
                \item problemów sprzętowych, np. false sharing
            \end{itemize}
            W naszym projekcie nie skorzystaliśmy ze wszystkich dostępnych analiz i metryk oferowanych przez VTune, lecz skupiliśmy się na informacjach oferowanych przez Microarchitecture Exploration.
        
        \subsection{Wyniki Uzyskane Dla Algorytmów Sekwencyjnych}
            Pierwszą grupą testowanych algorytmów, będą algorytmy sekwencyjne. Przeprowadzimy dla nich eksperymenty na wszystkich dostępnych zestawach testowych, które opisaliśmy powyżej. Ma to na celu identyfikację wszystkich cech stworzonych przez nas algorytmów sekwencyjnych. Dane zebrane w tym punkcie pomogą nam w określenie zmian wydajnościowych w dalszych analizach dla rozwiązań równoległyh.
            
            % TODO: add images
            
        \subsection{Wyniki Uzyskane Dla Algorytmów Równoległych}
            % TODO: add images too
            
        
    
    \clearpage
    \printnoidxglossaries
\end{document}